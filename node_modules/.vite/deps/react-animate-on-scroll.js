import {
  require_prop_types
} from "./chunk-SPAWSJ6I.js";
import "./chunk-DC55AYKO.js";
import {
  __commonJS,
  require_react
} from "./chunk-OMFGQDFA.js";

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/react-animate-on-scroll/dist/scrollAnimation.min.js
var require_scrollAnimation_min = __commonJS({
  "node_modules/react-animate-on-scroll/dist/scrollAnimation.min.js"(exports, module) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _get = function get(_x, _x2, _x3) {
      var _again = true;
      _function:
        while (_again) {
          var object = _x, property = _x2, receiver = _x3;
          _again = false;
          if (object === null)
            object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object);
            if (parent === null) {
              return void 0;
            } else {
              _x = parent;
              _x2 = property;
              _x3 = receiver;
              _again = true;
              desc = parent = void 0;
              continue _function;
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        }
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _lodashThrottle = require_lodash();
    var _lodashThrottle2 = _interopRequireDefault(_lodashThrottle);
    var _propTypes = require_prop_types();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var ScrollAnimation = function(_Component) {
      _inherits(ScrollAnimation2, _Component);
      function ScrollAnimation2(props) {
        _classCallCheck(this, ScrollAnimation2);
        _get(Object.getPrototypeOf(ScrollAnimation2.prototype), "constructor", this).call(this, props);
        this.serverSide = typeof window === "undefined";
        this.listener = (0, _lodashThrottle2["default"])(this.handleScroll.bind(this), 50);
        this.visibility = {
          onScreen: false,
          inViewport: false
        };
        this.state = {
          classes: "animated",
          style: {
            animationDuration: this.props.duration + "s",
            opacity: this.props.initiallyVisible ? 1 : 0
          }
        };
      }
      _createClass(ScrollAnimation2, [{
        key: "getElementTop",
        value: function getElementTop(elm) {
          var yPos = 0;
          while (elm && elm.offsetTop !== void 0 && elm.clientTop !== void 0) {
            yPos += elm.offsetTop + elm.clientTop;
            elm = elm.offsetParent;
          }
          return yPos;
        }
      }, {
        key: "getScrollPos",
        value: function getScrollPos() {
          if (this.scrollableParent.pageYOffset !== void 0) {
            return this.scrollableParent.pageYOffset;
          }
          return this.scrollableParent.scrollTop;
        }
      }, {
        key: "getScrollableParentHeight",
        value: function getScrollableParentHeight() {
          if (this.scrollableParent.innerHeight !== void 0) {
            return this.scrollableParent.innerHeight;
          }
          return this.scrollableParent.clientHeight;
        }
      }, {
        key: "getViewportTop",
        value: function getViewportTop() {
          return this.getScrollPos() + this.props.offset;
        }
      }, {
        key: "getViewportBottom",
        value: function getViewportBottom() {
          return this.getScrollPos() + this.getScrollableParentHeight() - this.props.offset;
        }
      }, {
        key: "isInViewport",
        value: function isInViewport(y) {
          return y >= this.getViewportTop() && y <= this.getViewportBottom();
        }
      }, {
        key: "isAboveViewport",
        value: function isAboveViewport(y) {
          return y < this.getViewportTop();
        }
      }, {
        key: "isBelowViewport",
        value: function isBelowViewport(y) {
          return y > this.getViewportBottom();
        }
      }, {
        key: "inViewport",
        value: function inViewport(elementTop, elementBottom) {
          return this.isInViewport(elementTop) || this.isInViewport(elementBottom) || this.isAboveViewport(elementTop) && this.isBelowViewport(elementBottom);
        }
      }, {
        key: "onScreen",
        value: function onScreen(elementTop, elementBottom) {
          return !this.isAboveScreen(elementBottom) && !this.isBelowScreen(elementTop);
        }
      }, {
        key: "isAboveScreen",
        value: function isAboveScreen(y) {
          return y < this.getScrollPos();
        }
      }, {
        key: "isBelowScreen",
        value: function isBelowScreen(y) {
          return y > this.getScrollPos() + this.getScrollableParentHeight();
        }
      }, {
        key: "getVisibility",
        value: function getVisibility() {
          var elementTop = this.getElementTop(this.node) - this.getElementTop(this.scrollableParent);
          var elementBottom = elementTop + this.node.clientHeight;
          return {
            inViewport: this.inViewport(elementTop, elementBottom),
            onScreen: this.onScreen(elementTop, elementBottom)
          };
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          if (!this.serverSide) {
            var parentSelector = this.props.scrollableParentSelector;
            this.scrollableParent = parentSelector ? document.querySelector(parentSelector) : window;
            if (this.scrollableParent && this.scrollableParent.addEventListener) {
              this.scrollableParent.addEventListener("scroll", this.listener);
            } else {
              console.warn("Cannot find element by locator: " + this.props.scrollableParentSelector);
            }
            if (this.props.animatePreScroll) {
              this.handleScroll();
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          clearTimeout(this.delayedAnimationTimeout);
          clearTimeout(this.callbackTimeout);
          if (window && window.removeEventListener) {
            window.removeEventListener("scroll", this.listener);
          }
        }
      }, {
        key: "visibilityHasChanged",
        value: function visibilityHasChanged(previousVis, currentVis) {
          return previousVis.inViewport !== currentVis.inViewport || previousVis.onScreen !== currentVis.onScreen;
        }
      }, {
        key: "animate",
        value: function animate(animation, callback) {
          var _this = this;
          this.delayedAnimationTimeout = setTimeout(function() {
            _this.animating = true;
            _this.setState({
              classes: "animated " + animation,
              style: {
                animationDuration: _this.props.duration + "s"
              }
            });
            _this.callbackTimeout = setTimeout(callback, _this.props.duration * 1e3);
          }, this.props.delay);
        }
      }, {
        key: "animateIn",
        value: function animateIn(callback) {
          var _this2 = this;
          this.animate(this.props.animateIn, function() {
            if (!_this2.props.animateOnce) {
              _this2.setState({
                style: {
                  animationDuration: _this2.props.duration + "s",
                  opacity: 1
                }
              });
              _this2.animating = false;
            }
            var vis = _this2.getVisibility();
            if (callback) {
              callback(vis);
            }
          });
        }
      }, {
        key: "animateOut",
        value: function animateOut(callback) {
          var _this3 = this;
          this.animate(this.props.animateOut, function() {
            _this3.setState({
              classes: "animated",
              style: {
                animationDuration: _this3.props.duration + "s",
                opacity: 0
              }
            });
            var vis = _this3.getVisibility();
            if (vis.inViewport && _this3.props.animateIn) {
              _this3.animateIn(_this3.props.afterAnimatedIn);
            } else {
              _this3.animating = false;
            }
            if (callback) {
              callback(vis);
            }
          });
        }
      }, {
        key: "handleScroll",
        value: function handleScroll() {
          if (!this.animating) {
            var currentVis = this.getVisibility();
            if (this.visibilityHasChanged(this.visibility, currentVis)) {
              clearTimeout(this.delayedAnimationTimeout);
              if (!currentVis.onScreen) {
                this.setState({
                  classes: "animated",
                  style: {
                    animationDuration: this.props.duration + "s",
                    opacity: this.props.initiallyVisible ? 1 : 0
                  }
                });
              } else if (currentVis.inViewport && this.props.animateIn) {
                this.animateIn(this.props.afterAnimatedIn);
              } else if (currentVis.onScreen && this.visibility.inViewport && this.props.animateOut && this.state.style.opacity === 1) {
                this.animateOut(this.props.afterAnimatedOut);
              }
              this.visibility = currentVis;
            }
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this4 = this;
          var classes = this.props.className ? this.props.className + " " + this.state.classes : this.state.classes;
          return _react2["default"].createElement(
            "div",
            { ref: function(node) {
              _this4.node = node;
            }, className: classes, style: Object.assign({}, this.state.style, this.props.style) },
            this.props.children
          );
        }
      }]);
      return ScrollAnimation2;
    }(_react.Component);
    exports["default"] = ScrollAnimation;
    ScrollAnimation.defaultProps = {
      offset: 150,
      duration: 1,
      initiallyVisible: false,
      delay: 0,
      animateOnce: false,
      animatePreScroll: true
    };
    ScrollAnimation.propTypes = {
      animateIn: _propTypes2["default"].string,
      animateOut: _propTypes2["default"].string,
      offset: _propTypes2["default"].number,
      duration: _propTypes2["default"].number,
      delay: _propTypes2["default"].number,
      initiallyVisible: _propTypes2["default"].bool,
      animateOnce: _propTypes2["default"].bool,
      style: _propTypes2["default"].object,
      scrollableParentSelector: _propTypes2["default"].string,
      className: _propTypes2["default"].string,
      animatePreScroll: _propTypes2["default"].bool
    };
    module.exports = exports["default"];
  }
});
export default require_scrollAnimation_min();
//# sourceMappingURL=react-animate-on-scroll.js.map
